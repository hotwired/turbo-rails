{"version":3,"file":"turbo-offline.min.js","sources":["../../../../../rosa/turbo/dist/turbo-offline.js"],"sourcesContent":["/*!\nTurbo 8.0.20\nCopyright Â© 2025 37signals LLC\n */\nclass Rule {\n  constructor({ handler, match = /.*/ } = {}) {\n    this.handler = handler;\n    this.match = match;\n  }\n\n  matches(request) {\n    if (typeof this.match === 'function') return this.match(request)\n\n    const regexes = Array.isArray(this.match) ? this.match : [this.match];\n    return regexes.some(regex => regex.test(request.url))\n  }\n\n  async handle(event) {\n    const { response, afterHandlePromise } = await this.handler.handle(event.request);\n    event.waitUntil(afterHandlePromise);\n\n    return response\n  }\n}\n\nclass ServiceWorker {\n  #started = false\n  #rules = []\n\n  addRule(rule) {\n    this.#rules.push(new Rule(rule));\n  }\n\n  start() {\n    this.#warnIfNoRulesConfigured();\n\n    if (!this.#started) {\n      self.addEventListener(\"install\", this.installed);\n      self.addEventListener(\"message\", this.messageReceived);\n      self.addEventListener(\"fetch\", this.fetch);\n      this.#started = true;\n    }\n  }\n\n  installed = (event) => {\n    // Just log for now\n    console.log(\"Service worker installed\");\n  }\n\n  messageReceived = (event) => {\n    if (this[event.data.action]) {\n      const actionCall = this[event.data.action](event.data.params);\n      event.waitUntil(actionCall);\n    }\n  }\n\n  fetch = (event) => {\n    if (this.#canInterceptRequest(event.request)) {\n      const rule = this.#findMatchingRule(event.request);\n      if (!rule) return\n\n      const response = rule.handle(event);\n      event.respondWith(response);\n    }\n  }\n\n  #warnIfNoRulesConfigured() {\n    if (this.#rules.length === 0) {\n      console.warn(\"No rules configured for service worker. No requests will be intercepted.\");\n    }\n  }\n\n  #canInterceptRequest(request) {\n    const url = new URL(request.url, location.href);\n    return request.method === \"GET\" && url.protocol.startsWith('http')\n  }\n\n  #findMatchingRule(request) {\n    return this.#rules.find((rule) => rule.matches(request))\n  }\n}\n\nconst DATABASE_NAME = \"turbo-offline-database\";\nconst DATABASE_VERSION = 1;\nconst STORE_NAME = \"cache-registry\";\n\nclass CacheRegistryDatabase {\n  get(cacheName, key) {\n    const getOp = (store) => this.#requestToPromise(store.get(key));\n    return this.#performOperation(STORE_NAME, getOp, \"readonly\")\n  }\n\n  has(cacheName, key) {\n    const countOp = (store) => this.#requestToPromise(store.count(key));\n    return this.#performOperation(STORE_NAME, countOp, \"readonly\").then((result) => result === 1)\n  }\n\n  put(cacheName, key, value) {\n    const putOp = (store) => {\n      const item = { key: key, cacheName: cacheName, timestamp: Date.now(), ...value };\n      store.put(item);\n      return this.#requestToPromise(store.transaction)\n    };\n\n    return this.#performOperation(STORE_NAME, putOp, \"readwrite\")\n  }\n\n  getTimestamp(cacheName, key) {\n    return this.get(cacheName, key).then((result) => result?.timestamp)\n  }\n\n  getOlderThan(cacheName, timestamp) {\n    const getOlderThanOp = (store) => {\n      const index = store.index(\"cacheNameAndTimestamp\");\n      // Use compound key range: [cacheName, timestamp]\n      const range = IDBKeyRange.bound(\n        [cacheName, 0], // start of range\n        [cacheName, timestamp], // end of range\n        false, // lowerOpen: include lower bound\n        true // upperOpen: exclude upper bound\n      );\n      const cursorRequest = index.openCursor(range);\n\n      return this.#cursorRequestToPromise(cursorRequest)\n    };\n    return this.#performOperation(STORE_NAME, getOlderThanOp, \"readonly\")\n  }\n\n  delete(cacheName, key) {\n    const deleteOp = (store) => this.#requestToPromise(store.delete(key));\n    return this.#performOperation(STORE_NAME, deleteOp, \"readwrite\")\n  }\n\n  #performOperation(storeName, operation, mode) {\n    return this.#openDatabase().then((database) => {\n      const transaction = database.transaction(storeName, mode);\n      const store = transaction.objectStore(storeName);\n      return operation(store)\n    })\n  }\n\n  #openDatabase() {\n    const request = indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n    request.onupgradeneeded = () => {\n      const cacheMetadataStore = request.result.createObjectStore(STORE_NAME, { keyPath: \"key\" });\n      cacheMetadataStore.createIndex(\"cacheNameAndTimestamp\", [ \"cacheName\", \"timestamp\" ]);\n    };\n\n    return this.#requestToPromise(request)\n  }\n\n  #requestToPromise(request) {\n    return new Promise((resolve, reject) => {\n      request.oncomplete = request.onsuccess = () => resolve(request.result);\n      request.onabort = request.onerror = () => reject(request.error);\n    })\n  }\n\n  #cursorRequestToPromise(request) {\n    return new Promise((resolve, reject) => {\n      const results = [];\n\n      request.onsuccess = (event) => {\n        const cursor = event.target.result;\n        if (cursor) {\n          results.push(cursor.value);\n          cursor.continue();\n        } else {\n          resolve(results);\n        }\n      };\n\n      request.onerror = () => reject(request.error);\n    })\n  }\n}\n\nlet cacheRegistryDatabase = null;\n\nfunction getDatabase() {\n  if (!cacheRegistryDatabase) {\n    cacheRegistryDatabase = new CacheRegistryDatabase();\n  }\n  return cacheRegistryDatabase\n}\n\nclass CacheRegistry {\n  constructor(cacheName) {\n    this.cacheName = cacheName;\n    this.database = getDatabase();\n  }\n\n  get(key) {\n    return this.database.get(this.cacheName, key)\n  }\n\n  has(key) {\n    return this.database.has(this.cacheName, key)\n  }\n\n  put(key, value = {}) {\n    return this.database.put(this.cacheName, key, value)\n  }\n\n  getTimestamp(key) {\n    return this.database.getTimestamp(this.cacheName, key)\n  }\n\n  getOlderThan(timestamp) {\n    return this.database.getOlderThan(this.cacheName, timestamp)\n  }\n\n  delete(key) {\n    return this.database.delete(this.cacheName, key)\n  }\n}\n\nclass CacheTrimmer {\n  #isRunning = false\n\n  constructor(cacheName, cacheRegistry, options = {}) {\n    this.cacheName = cacheName;\n    this.cacheRegistry = cacheRegistry;\n    this.options = options;\n  }\n\n  async trim() {\n    if (this.#isRunning) {\n      return\n    }\n\n    if (!this.#shouldTrim()) {\n      return\n    }\n\n    this.#isRunning = true;\n\n    try {\n      await this.deleteEntries();\n    } finally {\n      this.#isRunning = false;\n    }\n  }\n\n  #shouldTrim() {\n    // For now, only check maxAge. To be extended for maxEntries, maxStorage, etc.\n    return this.options.maxAge && this.options.maxAge > 0\n  }\n\n  async deleteEntries() {\n    if (this.options.maxAge) {\n      await this.deleteEntriesByAge();\n    }\n    // To be extended with other options\n  }\n\n  async deleteEntriesByAge() {\n    const maxAgeMs = this.options.maxAge * 1000;\n    const cutoffTimestamp = Date.now() - maxAgeMs;\n\n    const expiredEntries = await this.cacheRegistry.getOlderThan(cutoffTimestamp);\n\n    if (expiredEntries.length === 0) {\n      return\n    }\n\n    console.debug(`Trimming ${expiredEntries.length} expired entries from cache \"${this.cacheName}\"`);\n\n    const cache = await caches.open(this.cacheName);\n\n    const deletePromises = expiredEntries.map(async (entry) => {\n      const cacheDeletePromise = cache.delete(entry.key);\n      const registryDeletePromise = this.cacheRegistry.delete(entry.key);\n\n      return Promise.all([cacheDeletePromise, registryDeletePromise])\n    });\n\n    await Promise.all(deletePromises);\n\n    console.debug(`Successfully trimmed ${expiredEntries.length} entries from cache \"${this.cacheName}\"`);\n  }\n}\n\nclass Handler {\n  constructor({ cacheName, networkTimeout, maxAge }) {\n    this.cacheName = cacheName;\n    this.networkTimeout = networkTimeout;\n\n    this.cacheRegistry = new CacheRegistry(cacheName);\n    this.cacheTrimmer = new CacheTrimmer(cacheName, this.cacheRegistry, { maxAge });\n  }\n\n  async handle(request) {\n    // Abstract method\n  }\n\n  async fetchFromCache(request) {\n    const cacheKeyUrl = buildCacheKey(request);\n    let response = await caches.match(cacheKeyUrl, { ignoreVary: true });\n\n    if (response !== undefined && request.redirect === \"manual\" && response.redirected) {\n      // Can't respond with a redirected response to a request\n      // whose redirect mode is not \"follow\". Since we can't cache\n      // the request with manual redirect mode because these might be\n      // crawled in advance, when we don't know how these will be requested,\n      // we just return the body here.\n      response = new Response(response.body, { headers: response.headers, status: response.status, url: response.url });\n    }\n\n    return response\n  }\n\n  async fetchFromNetwork(request) {\n    // Setting the referrer so that it doesn't appear as the service worker\n    const referrer = request.referrer;\n    return await fetch(request, { referrer })\n  }\n\n  async saveToCache(request, response) {\n    if (response && this.canCacheResponse(response)) {\n      const cacheKeyUrl = buildCacheKey(request, response);\n      const cache = await caches.open(this.cacheName);\n\n      const cachePromise = cache.put(cacheKeyUrl, response);\n      const registryPromise = this.cacheRegistry.put(cacheKeyUrl);\n      const trimPromise = this.cacheTrimmer.trim();\n\n      return Promise.all([ cachePromise, registryPromise, trimPromise ])\n    }\n  }\n\n  canCacheResponse(response) {\n    // OK response and opaque responses (due to CORS), that have a 0 status\n    return response.status === 200 || response.status === 0\n  }\n}\n\nfunction buildCacheKey(requestOrUrl, response) {\n  // If the response is HTML, cache always based on the final response's request url, so\n  // that Turbo HTTP location redirects are not masked. Otherwise, cached based on the\n  // original request url, so redirected images, resources, etc are available offline.\n  // We don't have a response when responding from the cache because, so in that case,\n  // we need to use the request's URL always. This is also the case when we want to\n  // check the URL in our key-value store to see if we have a fresh version already.\n  const request = new Request(requestOrUrl);\n  const url = response && isHtmlResponse(response) ? response.url : request.url;\n  return new URL(url, location.href).href\n}\n\nfunction isHtmlResponse(response) {\n  return response.headers.get(\"content-type\")?.includes(\"text/html\")\n}\n\n/**\n * Cache-first: try the cache. If it's a hit, return that. If it's a miss,\n * fall back to network and then cache the response.\n */\n\nclass CacheFirst extends Handler {\n  async handle(request) {\n    let response = await this.fetchFromCache(request);\n    let afterHandlePromise;\n\n    if (response) {\n      // Always trim the cache when using a response in cache-first strategy\n      // because if we are always returning cached content and never saving\n      // any new content, it will all eventually become older than maxAge\n      afterHandlePromise = this.cacheTrimmer.trim();\n      return { response, afterHandlePromise }\n    }\n\n    console.debug(`Cache miss for ${request.url}`);\n\n    try {\n      response = await this.fetchFromNetwork(request);\n    } catch(error) {\n      console.warn(\n        `${error} fetching from network ${request.url}`\n       );\n    }\n\n    if (response) {\n      afterHandlePromise = this.saveToCache(request, response.clone());\n    }\n\n    return { response, afterHandlePromise }\n  }\n\n  canCacheResponse(response) {\n    // Only cache OK responses, as we don't want to cache a network error\n    // by mistake, which is impossible to distinguish from an opaque\n    // response with status 0\n    return response.status === 200\n  }\n}\n\n/**\n * Network-first: try the network, with an optional time out, and if that fails\n * fallback to the cache\n */\n\nclass NetworkFirst extends Handler {\n  async handle(request) {\n    let response;\n    let afterHandlePromise;\n    let timeoutId;\n    let cacheAttemptedOnTimeout = false;\n\n    const networkPromise = this.fetchFromNetwork(request);\n    const promises = [networkPromise];\n\n    if (this.networkTimeout) {\n      const timeoutPromise = new Promise((resolve) => {\n        timeoutId = setTimeout(async () => {\n          console.debug(`Network timeout after ${this.networkTimeout}s for ${request.url}, trying the cache...`);\n\n          const cachedResponse = await this.fetchFromCache(request);\n          cacheAttemptedOnTimeout = true;\n\n          resolve(cachedResponse);\n        }, this.networkTimeout * 1000);\n      });\n      promises.push(timeoutPromise);\n    }\n\n    try {\n      // Either the network wins or the timeout wins. The network might win\n      // with an error, though\n      response = await Promise.race(promises);\n    } catch(error) {\n      console.warn(\n        `${error} fetching from network ${request.url} with timeout`\n      );\n    }\n\n    if (timeoutId) clearTimeout(timeoutId);\n\n    if (!response && cacheAttemptedOnTimeout) {\n      // In this case we know we hit the timout and got a cache miss.\n      // We can wait for the network promise just in case, as we don't have\n      // anything to lose, knowing that we don't have the cache as fallback\n      try {\n        response = await networkPromise;\n      } catch(error) {\n        // This might be the same error we got from the promise race\n        console.warn(\n          `${error} fetching from network ${request.url}`\n        );\n      }\n    } else if (!response) {\n      // If we didn't get a response and didn't try the cache, try it now\n      // as a fallback\n      response = await this.fetchFromCache(request);\n    }\n\n    if (response) {\n      afterHandlePromise = this.saveToCache(request, response.clone());\n    } else {\n      afterHandlePromise = Promise.resolve();\n    }\n\n    return { response, afterHandlePromise }\n  }\n}\n\n/**\n * Stale-while-revalidate: try the cache. If it's a hit, return that and\n * go to the network to fetch a new response and store it. If it's a miss,\n * just fall back to network and then store the response.\n */\n\nclass StaleWhileRevalidate extends Handler {\n  async handle(request) {\n    let response = await this.fetchFromCache(request);\n    let afterHandlePromise;\n\n    if (response) {\n      afterHandlePromise = this.revalidateCache(request);\n      return { response, afterHandlePromise }\n    }\n\n    console.debug(`Cache miss for ${request.url}`);\n\n    try {\n      response = await this.fetchFromNetwork(request);\n    } catch(error) {\n      console.warn(\n        `${error} fetching from network ${request.url}`\n      );\n    }\n\n    if (response) {\n      afterHandlePromise = this.saveToCache(request, response.clone());\n    } else {\n      afterHandlePromise = Promise.resolve();\n    }\n\n    return { response, afterHandlePromise }\n  }\n\n  async revalidateCache(request) {\n    try {\n      const response = await this.fetchFromNetwork(request);\n      if (response) {\n        await this.saveToCache(request, response.clone());\n      }\n    } catch(error) {\n      console.debug(`${error} revalidating cache for ${request.url}`);\n    }\n  }\n}\n\nconst cacheFirst = (config) => new CacheFirst(config);\nconst networkFirst = (config) => new NetworkFirst(config);\nconst staleWhileRevalidate = (config) => new StaleWhileRevalidate(config);\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  cacheFirst: cacheFirst,\n  networkFirst: networkFirst,\n  staleWhileRevalidate: staleWhileRevalidate\n});\n\nconst serviceWorker = new ServiceWorker();\n\nfunction addRule(rule) {\n  serviceWorker.addRule(rule);\n}\n\nfunction start() {\n  serviceWorker.start();\n}\n\nexport { ServiceWorker, addRule, index as handlers, serviceWorker, start };\n"],"names":["Rule","constructor","handler","match","this","matches","request","Array","isArray","some","regex","test","url","handle","event","response","afterHandlePromise","waitUntil","ServiceWorker","started","rules","addRule","rule","push","start","warnIfNoRulesConfigured","self","addEventListener","installed","messageReceived","fetch","console","log","data","action","actionCall","params","canInterceptRequest","findMatchingRule","respondWith","length","warn","URL","location","href","method","protocol","startsWith","find","STORE_NAME","CacheRegistryDatabase","get","cacheName","key","performOperation","store","requestToPromise","has","count","then","result","put","value","item","timestamp","Date","now","transaction","getTimestamp","getOlderThan","index","range","IDBKeyRange","bound","cursorRequest","openCursor","cursorRequestToPromise","delete","storeName","operation","mode","openDatabase","database","objectStore","indexedDB","open","onupgradeneeded","createObjectStore","keyPath","createIndex","Promise","resolve","reject","oncomplete","onsuccess","onabort","onerror","error","results","cursor","target","continue","cacheRegistryDatabase","CacheRegistry","CacheTrimmer","isRunning","cacheRegistry","options","trim","shouldTrim","deleteEntries","maxAge","deleteEntriesByAge","maxAgeMs","cutoffTimestamp","expiredEntries","debug","cache","caches","deletePromises","map","async","entry","cacheDeletePromise","registryDeletePromise","all","Handler","networkTimeout","cacheTrimmer","fetchFromCache","cacheKeyUrl","buildCacheKey","ignoreVary","undefined","redirect","redirected","Response","body","headers","status","fetchFromNetwork","referrer","saveToCache","canCacheResponse","cachePromise","registryPromise","trimPromise","requestOrUrl","Request","includes","isHtmlResponse","CacheFirst","clone","NetworkFirst","timeoutId","cacheAttemptedOnTimeout","networkPromise","promises","timeoutPromise","setTimeout","cachedResponse","race","clearTimeout","StaleWhileRevalidate","revalidateCache","Object","freeze","__proto__","cacheFirst","config","networkFirst","staleWhileRevalidate","serviceWorker"],"mappings":"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"}