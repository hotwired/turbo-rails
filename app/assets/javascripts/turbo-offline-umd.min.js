!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).TurboOffline={})}(this,(function(e){"use strict";
/*!
  Turbo 8.0.20
  Copyright Â© 2025 37signals LLC
   */class t{constructor({handler:e,match:t=/.*/}={}){this.handler=e,this.match=t}matches(e){if("function"==typeof this.match)return this.match(e);return(Array.isArray(this.match)?this.match:[this.match]).some((t=>t.test(e.url)))}async handle(e){const{response:t,afterHandlePromise:s}=await this.handler.handle(e.request);return e.waitUntil(s),t}}class s{#e=!1;#t=[];addRule(e){this.#t.push(new t(e))}start(){this.#s(),this.#e||(self.addEventListener("install",this.installed),self.addEventListener("message",this.messageReceived),self.addEventListener("fetch",this.fetch),this.#e=!0)}installed=e=>{console.log("Service worker installed")};messageReceived=e=>{if(this[e.data.action]){const t=this[e.data.action](e.data.params);e.waitUntil(t)}};fetch=e=>{if(this.#r(e.request)){const t=this.#a(e.request);if(!t)return;const s=t.handle(e);e.respondWith(s)}};#s(){0===this.#t.length&&console.warn("No rules configured for service worker. No requests will be intercepted.")}#r(e){const t=new URL(e.url,location.href);return"GET"===e.method&&t.protocol.startsWith("http")}#a(e){return this.#t.find((t=>t.matches(e)))}}const r="cache-registry";class a{get(e,t){return this.#n(r,(e=>this.#i(e.get(t))),"readonly")}has(e,t){return this.#n(r,(e=>this.#i(e.count(t))),"readonly").then((e=>1===e))}put(e,t,s){return this.#n(r,(r=>{const a={key:t,cacheName:e,timestamp:Date.now(),...s};return r.put(a),this.#i(r.transaction)}),"readwrite")}getTimestamp(e,t){return this.get(e,t).then((e=>e?.timestamp))}getOlderThan(e,t){return this.#n(r,(s=>{const r=s.index("cacheNameAndTimestamp"),a=IDBKeyRange.bound([e,0],[e,t],!1,!0),n=r.openCursor(a);return this.#o(n)}),"readonly")}delete(e,t){return this.#n(r,(e=>this.#i(e.delete(t))),"readwrite")}#n(e,t,s){return this.#c().then((r=>{const a=r.transaction(e,s).objectStore(e);return t(a)}))}#c(){const e=indexedDB.open("turbo-offline-database",1);return e.onupgradeneeded=()=>{e.result.createObjectStore(r,{keyPath:"key"}).createIndex("cacheNameAndTimestamp",["cacheName","timestamp"])},this.#i(e)}#i(e){return new Promise(((t,s)=>{e.oncomplete=e.onsuccess=()=>t(e.result),e.onabort=e.onerror=()=>s(e.error)}))}#o(e){return new Promise(((t,s)=>{const r=[];e.onsuccess=e=>{const s=e.target.result;s?(r.push(s.value),s.continue()):t(r)},e.onerror=()=>s(e.error)}))}}let n=null;class i{constructor(e){this.cacheName=e,this.database=(n||(n=new a),n)}get(e){return this.database.get(this.cacheName,e)}has(e){return this.database.has(this.cacheName,e)}put(e,t={}){return this.database.put(this.cacheName,e,t)}getTimestamp(e){return this.database.getTimestamp(this.cacheName,e)}getOlderThan(e){return this.database.getOlderThan(this.cacheName,e)}delete(e){return this.database.delete(this.cacheName,e)}}class o{#h=!1;constructor(e,t,s={}){this.cacheName=e,this.cacheRegistry=t,this.options=s}async trim(){if(!this.#h&&this.#u()){this.#h=!0;try{await this.deleteEntries()}finally{this.#h=!1}}}#u(){return this.options.maxAge&&this.options.maxAge>0}async deleteEntries(){this.options.maxAge&&await this.deleteEntriesByAge()}async deleteEntriesByAge(){const e=1e3*this.options.maxAge,t=Date.now()-e,s=await this.cacheRegistry.getOlderThan(t);if(0===s.length)return;console.debug(`Trimming ${s.length} expired entries from cache "${this.cacheName}"`);const r=await caches.open(this.cacheName),a=s.map((async e=>{const t=r.delete(e.key),s=this.cacheRegistry.delete(e.key);return Promise.all([t,s])}));await Promise.all(a),console.debug(`Successfully trimmed ${s.length} entries from cache "${this.cacheName}"`)}}class c{constructor({cacheName:e,networkTimeout:t,maxAge:s}){this.cacheName=e,this.networkTimeout=t,this.cacheRegistry=new i(e),this.cacheTrimmer=new o(e,this.cacheRegistry,{maxAge:s})}async handle(e){}async fetchFromCache(e){const t=h(e);let s=await caches.match(t,{ignoreVary:!0});return void 0!==s&&"manual"===e.redirect&&s.redirected&&(s=new Response(s.body,{headers:s.headers,status:s.status,url:s.url})),s}async fetchFromNetwork(e){const t=e.referrer;return await fetch(e,{referrer:t})}async saveToCache(e,t){if(t&&this.canCacheResponse(t)){const s=h(e,t),r=(await caches.open(this.cacheName)).put(s,t),a=this.cacheRegistry.put(s),n=this.cacheTrimmer.trim();return Promise.all([r,a,n])}}canCacheResponse(e){return 200===e.status||0===e.status}}function h(e,t){const s=new Request(e),r=t&&function(e){return e.headers.get("content-type")?.includes("text/html")}(t)?t.url:s.url;return new URL(r,location.href).href}class u extends c{async handle(e){let t,s=await this.fetchFromCache(e);if(s)return t=this.cacheTrimmer.trim(),{response:s,afterHandlePromise:t};console.debug(`Cache miss for ${e.url}`);try{s=await this.fetchFromNetwork(e)}catch(t){console.warn(`${t} fetching from network ${e.url}`)}return s&&(t=this.saveToCache(e,s.clone())),{response:s,afterHandlePromise:t}}canCacheResponse(e){return 200===e.status}}class l extends c{async handle(e){let t,s,r,a=!1;const n=this.fetchFromNetwork(e),i=[n];if(this.networkTimeout){const t=new Promise((t=>{r=setTimeout((async()=>{console.debug(`Network timeout after ${this.networkTimeout}s for ${e.url}, trying the cache...`);const s=await this.fetchFromCache(e);a=!0,t(s)}),1e3*this.networkTimeout)}));i.push(t)}try{t=await Promise.race(i)}catch(t){console.warn(`${t} fetching from network ${e.url} with timeout`)}if(r&&clearTimeout(r),!t&&a)try{t=await n}catch(t){console.warn(`${t} fetching from network ${e.url}`)}else t||(t=await this.fetchFromCache(e));return s=t?this.saveToCache(e,t.clone()):Promise.resolve(),{response:t,afterHandlePromise:s}}}class m extends c{async handle(e){let t,s=await this.fetchFromCache(e);if(s)return t=this.revalidateCache(e),{response:s,afterHandlePromise:t};console.debug(`Cache miss for ${e.url}`);try{s=await this.fetchFromNetwork(e)}catch(t){console.warn(`${t} fetching from network ${e.url}`)}return t=s?this.saveToCache(e,s.clone()):Promise.resolve(),{response:s,afterHandlePromise:t}}async revalidateCache(e){try{const t=await this.fetchFromNetwork(e);t&&await this.saveToCache(e,t.clone())}catch(t){console.debug(`${t} revalidating cache for ${e.url}`)}}}var d=Object.freeze({__proto__:null,cacheFirst:e=>new u(e),networkFirst:e=>new l(e),staleWhileRevalidate:e=>new m(e)});const f=new s;e.ServiceWorker=s,e.addRule=function(e){f.addRule(e)},e.handlers=d,e.serviceWorker=f,e.start=function(){f.start()},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=turbo-offline-umd.min.js.map
